10 REM RIFF Format Support Test Suite
20 REM Copyright (c) 2024 Source Solutions, Inc.
30 REM 
40 REM This test suite verifies the RIFF format support
50 REM implementation in SE BASIC.
60 REM
70 REM Usage: LOAD "RIFFTEST.BAS" : RUN
80 REM
90 GOSUB 9000 : REM Initialize test framework
100 CLS
110 PRINT "RIFF Format Support Test Suite"
120 PRINT "============================="
130 PRINT
140 GOSUB 1000 : REM Run RIFF creation tests
150 GOSUB 2000 : REM Run RIFF reading tests
160 GOSUB 3000 : REM Run RIFF chunk tests
170 GOSUB 4000 : REM Run WAVE format tests
180 GOSUB 9500 : REM Print summary
190 END

1000 REM RIFF creation tests
1010 PRINT "RIFF Creation Tests:"
1020 PRINT "------------------"
1030 TOTAL% = 0 : PASSED% = 0
1040 REM Test SERIFFCreate
1050 TEST_FILE$ = "TEST.RIF"
1060 GOSUB 9100 : REM Test case
1070 DESC$ = "SERIFFCreate basic operation" : EXPECT% = 1 : ACTUAL% = 1
1080 ON ERROR GOTO 1100
1090 CALL USR(29, @TEST_FILE$) : GOTO 1110
1100 ACTUAL% = 0 : RESUME 1110
1110 GOSUB 9200 : REM Validate result
1120 REM Get handle and close file
1130 HANDLE% = USR(28)
1140 GOSUB 9100 : REM Test case
1150 DESC$ = "SERIFFCreate returns valid handle" : EXPECT% = 1 : ACTUAL% = (HANDLE% > 0)
1160 GOSUB 9200 : REM Validate result
1170 REM Close the file
1180 CALL USR(1, HANDLE%)
1190 REM Test SERIFFCreate with different RIFF type
1200 TEST_FILE$ = "TEST.WAV"
1210 GOSUB 9100 : REM Test case
1220 DESC$ = "SERIFFCreate with WAVE type" : EXPECT% = 1 : ACTUAL% = 1
1230 ON ERROR GOTO 1250
1240 POKE 23867, ASC("W") : POKE 23868, ASC("A") : POKE 23869, ASC("V") : POKE 23870, ASC("E")
1250 CALL USR(29, @TEST_FILE$) : GOTO 1260
1260 ACTUAL% = 0 : RESUME 1270
1270 GOSUB 9200 : REM Validate result
1280 REM Get handle and close file
1290 HANDLE% = USR(28)
1300 CALL USR(1, HANDLE%)
1310 GOSUB 9300 : REM Save section results
1320 RETURN

2000 REM RIFF reading tests
2010 PRINT "RIFF Reading Tests:"
2020 PRINT "-----------------"
2030 TOTAL% = 0 : PASSED% = 0
2040 REM Create a test RIFF file first
2050 TEST_FILE$ = "TEST2.RIF"
2060 POKE 23867, ASC("R") : POKE 23868, ASC("I") : POKE 23869, ASC("F") : POKE 23870, ASC("F")
2070 CALL USR(29, @TEST_FILE$)
2080 HANDLE% = USR(28)
2090 CALL USR(1, HANDLE%)
2100 REM Test SERIFFOpen
2110 GOSUB 9100 : REM Test case
2120 DESC$ = "SERIFFOpen basic operation" : EXPECT% = 1 : ACTUAL% = 1
2130 ON ERROR GOTO 2150
2140 CALL USR(27, @TEST_FILE$) : GOTO 2160
2150 ACTUAL% = 0 : RESUME 2160
2160 GOSUB 9200 : REM Validate result
2170 REM Verify the RIFF file is valid
2180 GOSUB 9100 : REM Test case
2190 DESC$ = "SERIFFOpen validation" : EXPECT% = 1 : ACTUAL% = (USR(28) = 0)
2200 GOSUB 9200 : REM Validate result
2210 REM Get handle
2220 HANDLE% = USR(28)
2230 CALL USR(1, HANDLE%)
2240 REM Test opening non-RIFF file
2250 GOSUB 9100 : REM Test case
2260 DESC$ = "SERIFFOpen invalid file detection" : EXPECT% = 0 : ACTUAL% = 0
2270 ON ERROR GOTO 2290
2280 CALL USR(27, "UNITTEST.BAS") : IF USR(28) = 0 THEN ACTUAL% = 1
2290 HANDLE% = USR(28)
2300 IF HANDLE% > 0 THEN CALL USR(1, HANDLE%)
2310 GOSUB 9200 : REM Validate result
2320 GOSUB 9300 : REM Save section results
2330 RETURN

3000 REM RIFF chunk tests
3010 PRINT "RIFF Chunk Tests:"
3020 PRINT "----------------"
3030 TOTAL% = 0 : PASSED% = 0
3040 REM Create a test RIFF file with chunks
3050 TEST_FILE$ = "CHUNKS.RIF"
3060 POKE 23867, ASC("T") : POKE 23868, ASC("E") : POKE 23869, ASC("S") : POKE 23870, ASC("T")
3070 CALL USR(29, @TEST_FILE$)
3080 HANDLE% = USR(28)
3090 REM Write TEST chunk
3100 POKE 23867, ASC("T") : POKE 23868, ASC("S") : POKE 23869, ASC("T") : POKE 23870, ASC("1")
3110 FOR I = 0 TO 15 : POKE 23880+I, I : NEXT I
3120 GOSUB 9100 : REM Test case
3130 DESC$ = "SERIFFWriteChunk basic operation" : EXPECT% = 1 : ACTUAL% = 1
3140 ON ERROR GOTO 3160
3150 CALL USR(30, HANDLE%, 23880, 16) : GOTO 3170
3160 ACTUAL% = 0 : RESUME 3170
3170 GOSUB 9200 : REM Validate result
3180 REM Write a second chunk
3190 POKE 23867, ASC("T") : POKE 23868, ASC("S") : POKE 23869, ASC("T") : POKE 23870, ASC("2")
3200 FOR I = 0 TO 7 : POKE 23880+I, 255-I : NEXT I
3210 CALL USR(30, HANDLE%, 23880, 8)
3220 CALL USR(1, HANDLE%)
3230 REM Now read the file and check chunks
3240 CALL USR(27, @TEST_FILE$)
3250 HANDLE% = USR(28)
3260 REM Read first chunk
3270 POKE 23867, ASC("T") : POKE 23868, ASC("S") : POKE 23869, ASC("T") : POKE 23870, ASC("1")
3280 GOSUB 9100 : REM Test case
3290 DESC$ = "SERIFFReadChunk finds chunk" : EXPECT% = 1 : ACTUAL% = 1
3300 ON ERROR GOTO 3320
3310 CALL USR(28, HANDLE%, 23880, 23867) : GOTO 3330
3320 ACTUAL% = 0 : RESUME 3330
3330 GOSUB 9200 : REM Validate result
3340 REM Verify chunk size
3350 GOSUB 9100 : REM Test case
3360 DESC$ = "SERIFFReadChunk correct size" : EXPECT% = 16 : ACTUAL% = USR(29)
3370 GOSUB 9200 : REM Validate result
3380 REM Verify chunk data
3390 GOSUB 9100 : REM Test case
3400 DESC$ = "SERIFFReadChunk correct data" : EXPECT% = 7 : ACTUAL% = PEEK(23887)
3410 GOSUB 9200 : REM Validate result
3420 REM Read second chunk
3430 POKE 23867, ASC("T") : POKE 23868, ASC("S") : POKE 23869, ASC("T") : POKE 23870, ASC("2")
3440 CALL USR(28, HANDLE%, 23880, 23867)
3450 GOSUB 9100 : REM Test case
3460 DESC$ = "SERIFFReadChunk second chunk" : EXPECT% = 8 : ACTUAL% = USR(29)
3470 GOSUB 9200 : REM Validate result
3480 REM Try to read non-existent chunk
3490 POKE 23867, ASC("N") : POKE 23868, ASC("O") : POKE 23869, ASC("P") : POKE 23870, ASC("E")
3500 GOSUB 9100 : REM Test case
3510 DESC$ = "SERIFFReadChunk missing chunk" : EXPECT% = 0 : ACTUAL% = 0
3520 CALL USR(28, HANDLE%, 23880, 23867) : IF USR(28) = 0 THEN ACTUAL% = 1
3530 GOSUB 9200 : REM Validate result
3540 CALL USR(1, HANDLE%)
3550 GOSUB 9300 : REM Save section results
3560 RETURN

4000 REM WAVE format tests
4010 PRINT "WAVE Format Tests:"
4020 PRINT "-----------------"
4030 TOTAL% = 0 : PASSED% = 0
4040 REM Create a test WAVE file
4050 TEST_FILE$ = "TEST.WAV"
4060 POKE 23867, ASC("W") : POKE 23868, ASC("A") : POKE 23869, ASC("V") : POKE 23870, ASC("E")
4070 CALL USR(29, @TEST_FILE$)
4080 HANDLE% = USR(28)
4090 REM Add fmt chunk (PCM format)
4100 POKE 23867, ASC("f") : POKE 23868, ASC("m") : POKE 23869, ASC("t") : POKE 23870, ASC(" ")
4110 REM Format = PCM (1)
4120 POKE 23880, 1 : POKE 23881, 0
4130 REM Channels = 2 (stereo)
4140 POKE 23882, 2 : POKE 23883, 0
4150 REM Sample rate = 44100
4160 POKE 23884, 68 : POKE 23885, 172 : POKE 23886, 0 : POKE 23887, 0
4170 REM Bytes/sec = 176400
4180 POKE 23888, 16 : POKE 23889, 177 : POKE 23890, 2 : POKE 23891, 0
4190 REM Block align = 4
4200 POKE 23892, 4 : POKE 23893, 0
4210 REM Bits/sample = 16
4220 POKE 23894, 16 : POKE 23895, 0
4230 GOSUB 9100 : REM Test case
4240 DESC$ = "WAVE fmt chunk writing" : EXPECT% = 1 : ACTUAL% = 1
4250 ON ERROR GOTO 4270
4260 CALL USR(30, HANDLE%, 23880, 16) : GOTO 4280
4270 ACTUAL% = 0 : RESUME 4280
4280 GOSUB 9200 : REM Validate result
4290 REM Add data chunk with a simple wave
4300 POKE 23867, ASC("d") : POKE 23868, ASC("a") : POKE 23869, ASC("t") : POKE 23870, ASC("a")
4310 FOR I = 0 TO 19 STEP 2
4320   V = INT(10000 * SIN(I/3))
4330   POKE 23880+I, V AND 255
4340   POKE 23881+I, (V/256) AND 255
4350 NEXT I
4360 GOSUB 9100 : REM Test case
4370 DESC$ = "WAVE data chunk writing" : EXPECT% = 1 : ACTUAL% = 1
4380 ON ERROR GOTO 4400
4390 CALL USR(30, HANDLE%, 23880, 20) : GOTO 4410
4400 ACTUAL% = 0 : RESUME 4410
4410 GOSUB 9200 : REM Validate result
4420 CALL USR(1, HANDLE%)
4430 REM Now verify the WAVE file
4440 CALL USR(27, @TEST_FILE$)
4450 HANDLE% = USR(28)
4460 GOSUB 9100 : REM Test case
4470 DESC$ = "WAVE file validation" : EXPECT% = 1 : ACTUAL% = (USR(28) = 0)
4480 GOSUB 9200 : REM Validate result
4490 REM Read fmt chunk
4500 POKE 23867, ASC("f") : POKE 23868, ASC("m") : POKE 23869, ASC("t") : POKE 23870, ASC(" ")
4510 CALL USR(28, HANDLE%, 23880, 23867)
4520 GOSUB 9100 : REM Test case
4530 DESC$ = "WAVE fmt chunk format check" : EXPECT% = 1 : ACTUAL% = PEEK(23880)
4540 GOSUB 9200 : REM Validate result
4550 GOSUB 9100 : REM Test case
4560 DESC$ = "WAVE fmt chunk channels check" : EXPECT% = 2 : ACTUAL% = PEEK(23882)
4570 GOSUB 9200 : REM Validate result
4580 GOSUB 9100 : REM Test case
4590 DESC$ = "WAVE fmt chunk sample bits check" : EXPECT% = 16 : ACTUAL% = PEEK(23894)
4600 GOSUB 9200 : REM Validate result
4610 REM Read data chunk
4620 POKE 23867, ASC("d") : POKE 23868, ASC("a") : POKE 23869, ASC("t") : POKE 23870, ASC("a")
4630 CALL USR(28, HANDLE%, 23880, 23867)
4640 GOSUB 9100 : REM Test case
4650 DESC$ = "WAVE data chunk size" : EXPECT% = 20 : ACTUAL% = USR(29)
4660 GOSUB 9200 : REM Validate result
4670 CALL USR(1, HANDLE%)
4680 GOSUB 9300 : REM Save section results
4690 KILL "TEST.RIF"
4700 KILL "TEST.WAV"
4710 KILL "CHUNKS.RIF"
4720 RETURN

9000 REM Test framework initialization
9010 GLOBAL_TOTAL% = 0
9020 GLOBAL_PASSED% = 0
9030 SECTIONS% = 0
9040 SEC_TOTAL% = 0
9050 SEC_PASSED% = 0
9060 DIM SEC_NAME$(4)
9070 DIM SEC_TOTAL%(4)
9080 DIM SEC_PASSED%(4)
9090 RETURN

9100 REM Test case setup
9110 TOTAL% = TOTAL% + 1
9120 RETURN

9200 REM Validate numeric result
9210 IF ACTUAL% = EXPECT% THEN PASSED% = PASSED% + 1 : RESULT$ = "PASS" ELSE RESULT$ = "FAIL"
9220 PRINT "  [";RESULT$;"] "; DESC$; " ("; ACTUAL%; " = "; EXPECT%; ")"
9230 RETURN

9300 REM Save section results
9310 SECTIONS% = SECTIONS% + 1
9320 SEC_NAME$(SECTIONS%) = MID$(DESC$, 1, INSTR(DESC$, " ")-1)
9330 IF SEC_NAME$(SECTIONS%) = "" THEN SEC_NAME$(SECTIONS%) = "Section " + STR$(SECTIONS%)
9340 SEC_TOTAL%(SECTIONS%) = TOTAL%
9350 SEC_PASSED%(SECTIONS%) = PASSED%
9360 GLOBAL_TOTAL% = GLOBAL_TOTAL% + TOTAL%
9370 GLOBAL_PASSED% = GLOBAL_PASSED% + PASSED%
9380 PRINT "  -> Results: "; PASSED%; "/"; TOTAL%; " tests passed (";
9390 IF TOTAL% > 0 THEN PRINT INT(PASSED% * 100 / TOTAL%); ELSE PRINT "0";
9400 PRINT "%)"
9410 PRINT
9420 RETURN

9500 REM Print summary
9510 PRINT "Test Summary:"
9520 PRINT "============="
9530 FOR I = 1 TO SECTIONS%
9540   PRINT SEC_NAME$(I); " Tests: "; SEC_PASSED%(I); "/"; SEC_TOTAL%(I); " (";
9550   IF SEC_TOTAL%(I) > 0 THEN PRINT INT(SEC_PASSED%(I) * 100 / SEC_TOTAL%(I)); ELSE PRINT "0";
9560   PRINT "%)"
9570 NEXT I
9580 PRINT "-------------"
9590 PRINT "Overall: "; GLOBAL_PASSED%; "/"; GLOBAL_TOTAL%; " (";
9600 IF GLOBAL_TOTAL% > 0 THEN PRINT INT(GLOBAL_PASSED% * 100 / GLOBAL_TOTAL%); ELSE PRINT "0";
9610 PRINT "%)"
9620 RETURN